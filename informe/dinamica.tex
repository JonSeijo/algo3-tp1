\subsection{Solución topdown}

Generar todas las combinaciones es muy caro computacionalmente. Se puede conseguir algo mejor si pensamos el problema desde otro ángulo. \\

Supongamos que ya tenemos el valor minimo de elementos sin pintar dado que el i-ésimo es el ultimo rojo y el j-ésimo es el último azul. De este modo, lo único que tendríamos que hacer es tomar el mínimo de todos los resultados dados los ultimos rojos y azules. \\

Entonces nuestro problema se reduce a: suponiedo que la secuencia tiene el último rojo y el último azul en posiciones fijas, ¿cuál es la minima cantidad de elementos sin pintar que podemos obtener? \\

Las observaciones claves son las siguientes:

\begin{enumerate}
\item Se quiere obtener el
\item Recorriendo de izquierda a derecha, lo único que se necesita para saber si es válido pintar cierto elemento de algun color, es ver el valor del último elemento antes del actual que fue pintado de ese mismo color.
\item Puede conocerse la cantidad de elementos sin pintar a medida que se va pintando la secuencia.
\item La cantidad de elementos sin pintar \textbf{no} aumenta si se pinta rojo o azul.
\item Si la cantidad de elementos sin pintar es mayor al mínimo entontrado, entonces no vale la pena seguir explorando esa secuencia, pues la cantidad de elementos sin pintar no puede disminuir.
\end{enumerate}



\subsection{Pseudocódigo topdown}

\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{Resolver topdown}{secuencia(int) $A$}
  \State Matriz3 $DP \gets$ Matriz3($n$, $-1$) \Comment Matriz de 3 dimensiones, llena con $-1$
    \For {$ultRojo \in [0..n]$}
        \For {$ultAzul \in [0..n]$}
            \State $minSinPintar \gets$ Min($minSinPintar$, Solución($n-1$, $ultRojo$, $ultAzul$))
        \EndFor
    \EndFor
    \State return $minSinPintar$
\EndProcedure
\end{algorithmic}
\end{algorithm} 


\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{Solución}{int $actual$, int $ultRojo$, int $ultAzul$} %\Comment($ur$: último rojo;  $ua$: último azul)
    \If {$actual = -1$}
        return $0$
    \EndIf
    \If {DP[$actual$][$ultRojo$][$ultAzul$] $\neq -1$}
        return DP[$actual$][$ultRojo$][$ultAzul$]
    \EndIf \\

    \State $minRojo \gets$ TopdownCasoRojo($actual$, $ultRojo$, $ultAzul$)
    \State $minAzul \gets$ TopdownCasoAzul($actual$, $ultRojo$, $ultAzul$)
    \State $minSinPintar \gets$ TopdownCasoSinPintar($actual$, $ultRojo$, $ultAzul$) \\

    \State return Min($minRojo$, $minAzul$, $minSinPintar$)
\EndProcedure
\end{algorithmic}
\end{algorithm} 


\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{TopdownCasoRojo}{int $actual$, int $ultRojo$, int $ultAzul$} %\Comment($ur$: último rojo;  $ua$: último azul)
    \Comment Si no hay rojo o si el actual es azul, entonces no puedo considerar que el actual sea rojo
    \If {$(ultRojo = n)  \lor (actual = ultAzul)$}
        \State return $\infty$
    
    \Else \Comment Si soy el último rojo, ó si puedo serlo porque cumplo la propiedad:
        \If {($actual = ultRojo$) $\lor$ ($ i < ultRojo \land A[i] < A[ultRojo]$)}
            \State return Solución($actual - 1$, $actual$, $ultAzul$)
        \Else 
            \State return $\infty$
        \EndIf 
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{TopdownCasoAzul}{int $actual$, int $ultRojo$, int $ultAzul$} \\ %\Comment($ur$: último rojo;  $ua$: último azul)
    \Comment Si no hay azul o si el actual es rojo, entonces no puedo considerar que el actual sea azul
    \If {$(ultAzul = n)  \lor (actual = ultRojo)$}
        \State return $\infty$
    
    \Else \Comment Si soy el último azul, ó si puedo serlo porque cumplo la propiedad:
        \If {($actual = ultAzul$) $\lor$ ($ i < ultAzul \land A[i] > A[ultAzul]$)}
            \State return Solución($actual - 1$, $ultAzul$, $actual$)
        \Else 
            \State return $\infty$
        \EndIf 
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm} 


\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{TopdownCasoSinPintar}{int $actual$, int $ultRojo$, int $ultAzul$} \\
    \Comment No puede pasar que el actual sea rojo o azul, pero que lo quiera dejar sin pintar
    \If {$(actual = ultRojo)  \lor (actual = ultAzul)$}
        \State return $\infty$
    \Else 
        \State return $1 + $  Solución($actual - 1$, $ultRojo$, $ultAzul$)
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}

Aca va la justificacion de por que el algoritmo topdown es $n^3$, consultar mis notas para orientacion
